@{
    ViewData["Title"] = "Radio Hub";
}

<div class="container mt-4">
    <div class="row">
        <div class="col-md-8">
            <!-- Player Section -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5>🎵 Now Playing</h5>
                </div>
                <div class="card-body text-center">
                    <!-- Now Playing Info -->
                    <div id="nowPlaying" class="mb-3">
                        <p class="text-muted">No song is currently playing</p>
                    </div>

                    <!-- Visualizer -->
                    <canvas id="visualizer" width="600" height="100" style="width: 100%; background: #f8f9fa; border-radius: 5px;"></canvas>

                    <!-- Live Stream Button -->
                    <div class="mt-3">
                        <button id="listenLiveBtn" class="btn btn-success btn-lg">
                            <i class="bi bi-broadcast"></i> Listen Live
                        </button>
                        <p class="text-muted small mt-2">Click to start the live radio broadcast</p>
                    </div>
                </div>
            </div>

            <!-- Search Section -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5>🔍 Search for Songs</h5>
                </div>
                <div class="card-body">
                    <div class="input-group mb-3">
                        <input type="text" id="searchQuery" class="form-control" placeholder="Enter song name or artist..." />
                        <button class="btn btn-primary" id="searchButton">
                            <i class="bi bi-search"></i> Search
                        </button>
                    </div>
                    <div id="searchResults" class="row">
                        <!-- Search results will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <!-- Queue Section -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>📋 Queue</h5>
                    <button id="clearQueueBtn" class="btn btn-sm btn-outline-danger">Clear</button>
                </div>
                <div class="card-body">
                    <div id="queueStatus" class="mb-3 p-3 bg-light rounded">
                        <p class="mb-1"><strong>Total songs:</strong> <span id="totalSongs" class="badge bg-primary">0</span></p>
                        <p class="mb-0"><strong>Status:</strong> <span id="playingStatus" class="badge bg-secondary">Not playing</span></p>
                    </div>
                    <div id="songQueue" class="list-group" style="max-height: 500px; overflow-y: auto;">
                        <!-- Queue items populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Request Song Modal -->
<div class="modal fade" id="requestModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">🎵 Request Song</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p>You're requesting: <strong id="requestModalSongTitle"></strong></p>
                <div class="mb-3">
                    <label for="requesterName" class="form-label">Your Name:</label>
                    <input type="text" class="form-control" id="requesterName" placeholder="Enter your name" required>
                    <div class="invalid-feedback" id="requesterNameError" style="display: none;">
                        Please enter your name.
                    </div>
                </div>
                <div class="mb-3">
                    <label for="requesterNote" class="form-label">Message/Note (optional):</label>
                    <textarea class="form-control" id="requesterNote" placeholder="Write a note to the DJ"></textarea>
                </div>
                <input type="hidden" id="requestModalVideoId">
                <input type="hidden" id="requestModalTitle">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="confirmRequestBtn">
                    <i class="bi bi-check-circle"></i> Request Song
                </button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>

    <script>
        // Global variables
        let liveAudioPlayer = null;
        let isLivePlaying = false;
        let connection = null;
        let queue = [];
        let currentlyPlaying = null;
        const ICECAST_URL = 'http://localhost:8087/live';
        let autoReconnectEnabled = false;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // Initialize on page ready
        $(document).ready(function() {
            initializeSignalR();
            setupEventHandlers();
            // Load queue status on initial page load
            loadQueueStatus();
        });

        // SignalR for queue updates
        function initializeSignalR() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl('/radioHub')
                .withAutomaticReconnect([0, 2000, 5000, 10000, 30000]) // Automatic reconnection strategy
                .configureLogging(signalR.LogLevel.Information)
                .build();

            connection.on('PlaylistUpdated', updateQueueDisplay);
            connection.on('SongStarted', data => {
                console.log('SongStarted event received:', data);
                updateNowPlaying(data);
                // Also refresh the queue to highlight the currently playing song
                loadQueueStatus();
            });
            connection.on('SongEnded', data => {
                console.log('SongEnded event received');
                currentlyPlaying = null;
                // Refresh queue when song ends to update UI
                loadQueueStatus();
            });
            connection.on('QueueUpdated', data => {
                console.log('QueueUpdated event received');
                loadQueueStatus();
            });

            // Connection state events for debugging and error handling
            connection.onreconnecting(error => {
                console.warn('SignalR reconnecting due to error:', error);
                showToast('Reconnecting to radio server...', 'warning');
            });
            
            connection.onreconnected(connectionId => {
                console.log('SignalR reconnected with ID:', connectionId);
                showToast('Reconnected to radio server!', 'success');
                loadQueueStatus(); // Refresh data after reconnection
            });
            
            connection.onclose(error => {
                console.error('SignalR connection closed with error:', error);
                showToast('Connection to radio server lost. Please refresh the page.', 'danger');
            });

            // Start the connection
            startSignalRConnection();
        }
        
        // Function to start SignalR connection with retry logic
        function startSignalRConnection() {
            console.log('Attempting to connect to SignalR hub...');
            connection.start()
                .then(() => {
                    console.log('SignalR connected successfully');
                    showToast('Connected to radio server', 'success');
                })
                .catch(err => {
                    console.error('SignalR connection error:', err);
                    showToast('Failed to connect to radio server. Retrying...', 'warning');
                    setTimeout(startSignalRConnection, 1000); // Retry after 1 seconds
                });
        }

        // Event handlers
        function setupEventHandlers() {
            $('#listenLiveBtn').click(toggleLiveStream);
            $('#searchButton').click(searchSongs);
            $('#searchQuery').keypress(e => { if (e.which === 13) searchSongs(); });
            $('#confirmRequestBtn').click(confirmRequest);
            $('#requesterName').keypress(e => { if(e.which === 13) confirmRequest(); });
            $('#clearQueueBtn').click(clearQueue);
        }

        // Live Stream Play/Stop
        function toggleLiveStream() {
            if (isLivePlaying) stopLiveStream();
            else playLiveStream();
        }

        function playLiveStream() {
            if (isLivePlaying) return;
            
            // Enable auto-reconnect for future interruptions
            autoReconnectEnabled = true;
            reconnectAttempts = 0;
            
            // Check if we already have an audio player, clean it up first
            if (liveAudioPlayer) {
                liveAudioPlayer.pause();
                liveAudioPlayer.src = '';
                liveAudioPlayer.load();
                liveAudioPlayer = null;
            }

            // Create new audio player with crossOrigin attribute
            liveAudioPlayer = new Audio();
            liveAudioPlayer.crossOrigin = "anonymous"; // Add CORS header
            liveAudioPlayer.autoplay = true;
            
            // Set source after setting crossOrigin
            liveAudioPlayer.src = ICECAST_URL;

            // Update button immediately to provide visual feedback
            $('#listenLiveBtn').prop('disabled', true).html('<span class="spinner-border spinner-border-sm"></span> Connecting...');

            // Add event listeners
            liveAudioPlayer.addEventListener('playing', () => {
                console.log('Audio stream is playing');
                isLivePlaying = true;
                updateLiveButton();
                showToast('Live stream started successfully', 'success');
                // Only start visualizer after confirmed playing
                startVisualizer();
                // Reset reconnect attempts on successful connection
                reconnectAttempts = 0;
            });
            
            liveAudioPlayer.addEventListener('pause', () => {
                console.log('Audio stream paused');
                // Only update UI if this wasn't triggered by an auto-reconnect
                if (!autoReconnectEnabled || reconnectAttempts === 0) {
                    isLivePlaying = false;
                    updateLiveButton();
                }
            });
            
            // Handle ended event - attempt to reconnect if auto-reconnect is enabled
            liveAudioPlayer.addEventListener('ended', () => {
                console.log('Audio stream ended');
                handleStreamInterruption('Stream ended. This may happen when a new song starts.');
            });
            
            // Handle stalled event - attempt to reconnect if auto-reconnect is enabled
            liveAudioPlayer.addEventListener('stalled', () => {
                console.log('Audio stream stalled');
                handleStreamInterruption('Stream stalled. Attempting to reconnect...');
            });
            
            // Handle error event
            liveAudioPlayer.addEventListener('error', e => {
                console.error('Stream error code:', liveAudioPlayer.error ? liveAudioPlayer.error.code : 'unknown', e);
                
                // Only update UI if this wasn't triggered by an auto-reconnect or if we've exceeded max attempts
                if (!autoReconnectEnabled || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                    isLivePlaying = false;
                    updateLiveButton();
                    $('#listenLiveBtn').prop('disabled', false);
                    
                    // Show specific error message based on error code
                    let errorMsg = 'Error connecting to live stream. Please try again.';
                    if (liveAudioPlayer.error) {
                        switch(liveAudioPlayer.error.code) {
                            case 1: errorMsg = 'Stream aborted. Please try again.'; break;
                            case 2: errorMsg = 'Network error. Please check your connection.'; break;
                            case 3: errorMsg = 'Audio decoding error. The stream may be unavailable.'; break;
                            case 4: errorMsg = 'Stream not supported. Please contact support.'; break;
                        }
                    }
                    showToast(errorMsg, 'danger');
                } else {
                    // Attempt to reconnect
                    handleStreamInterruption('Stream error. Attempting to reconnect...');
                }
            });

            // Try to play and handle promise
            console.log('Attempting to play audio stream...');
            let playPromise = liveAudioPlayer.play();
            
            // Modern browsers return a promise from play()
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        console.log('Play promise resolved successfully');
                        // The playing event will handle the rest
                    })
                    .catch(err => {
                        console.error('Error starting stream:', err);
                        
                        if (!autoReconnectEnabled || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                            isLivePlaying = false;
                            $('#listenLiveBtn').prop('disabled', false).html('<i class="bi bi-broadcast"></i> Listen Live');
                            
                            if (err.name === 'NotAllowedError') {
                                showToast('Autoplay blocked. Please click play again to start the stream.', 'warning');
                            } else {
                                showToast('Failed to start stream. Please try again.', 'danger');
                            }
                        } else {
                            // Attempt to reconnect
                            handleStreamInterruption('Failed to start stream. Attempting to reconnect...');
                        }
                    });
            }
        }
        
        // Function to handle stream interruptions and attempt reconnection
        function handleStreamInterruption(message) {
            if (!autoReconnectEnabled || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                // If auto-reconnect is disabled or max attempts reached, just stop
                console.log('Stream interrupted, auto-reconnect disabled or max attempts reached');
                stopLiveStream();
                showToast('Stream interrupted. Please click play to restart.', 'warning');
                return;
            }
            
            reconnectAttempts++;
            console.log(`Stream interrupted. Reconnect attempt ${reconnectAttempts}/5`);
            
            // Show toast with reconnect attempt info and countdown
            const retrySeconds = 5;
            showToast(`${message} Reconnect attempt ${reconnectAttempts}/5 in ${retrySeconds} seconds...`, 'info');
            
            // Clean up existing player
            if (liveAudioPlayer) {
                liveAudioPlayer.pause();
                liveAudioPlayer.src = '';
                liveAudioPlayer.load();
                liveAudioPlayer = null;
            }
            
            // Update button to show countdown
            const btn = $('#listenLiveBtn');
            btn.prop('disabled', true).html(`<i class="bi bi-arrow-clockwise"></i> Reconnecting in ${retrySeconds}s...`);
            
            // Wait 1 seconds before reconnecting
            setTimeout(() => {
                // Only attempt to reconnect if we're still supposed to be playing
                if (autoReconnectEnabled) {
                    console.log('Attempting to reconnect to stream...');
                    playLiveStream();
                }
            }, 1000); 
        }

        function stopLiveStream() {
            // Disable auto-reconnect when manually stopping
            autoReconnectEnabled = false;
            reconnectAttempts = 0;
            
            if (!liveAudioPlayer) return;
            liveAudioPlayer.pause();
            liveAudioPlayer.src = '';
            liveAudioPlayer.load();
            isLivePlaying = false;
            updateLiveButton();
            stopVisualizer();
        }

        function updateLiveButton() {
            const btn = $('#listenLiveBtn');
            if (isLivePlaying) {
                btn.html('<i class="bi bi-stop-fill"></i> Stop Live Stream').removeClass('btn-success').addClass('btn-danger');
            } else {
                btn.html('<i class="bi bi-broadcast"></i> Listen Live').removeClass('btn-danger').addClass('btn-success');
            }
        }

        let canvas, ctx, animationId;
        let audioContext, analyser, source;
        let frequencyData;

        function startVisualizer() {
            if (!liveAudioPlayer) return;
            
            try {
                // Stop previous visualizer if it exists
                stopVisualizer();
                
                canvas = document.getElementById('visualizer');
                ctx = canvas.getContext('2d');
                
                // Make canvas responsive - set width to match container
                canvas.width = canvas.parentElement.clientWidth;
    
                // Web Audio API setup
                // Always create a new audio context for each song
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // Number of samples, smaller = smoother
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                
                try {
                    source = audioContext.createMediaElementSource(liveAudioPlayer);
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                } catch (err) {
                    console.error('Error connecting audio source:', err);
                    // Continue with visualization disabled but audio still plays
                    return;
                }
    
                function draw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    try {
                        analyser.getByteFrequencyData(frequencyData);
                        
                        const bars = frequencyData.length;
                        const barWidth = canvas.width / bars;
        
                        for (let i = 0; i < bars; i++) {
                            const value = frequencyData[i];
                            const percent = value / 255;
                            const barHeight = percent * canvas.height;
        
                            const hue = 120 - percent * 120; // green to red
                            ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                            ctx.shadowColor = `hsl(${hue}, 80%, 50%)`;
                            ctx.shadowBlur = 10;
        
                            ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth - 1, barHeight);
                        }
                    } catch (err) {
                        console.error('Error in visualizer:', err);
                    }
                    
                    animationId = requestAnimationFrame(draw);
                }

                draw();
            } catch (err) {
                console.error('Failed to start visualizer:', err);
                // Audio can still play even if visualizer fails
            }
        }

        function stopVisualizer() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            if (ctx && canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            // Clean up audio context and resources
            if (source) {
                try {
                    source.disconnect();
                    source = null;
                } catch (err) {
                    console.error('Error disconnecting audio source:', err);
                }
            }
            
            if (audioContext) {
                try {
                    audioContext.close().catch(err => console.error('Error closing audio context:', err));
                    audioContext = null;
                    analyser = null;
                    frequencyData = null;
                } catch (err) {
                    console.error('Error closing audio context:', err);
                }
            }
        }


        // Queue handling
        function updateQueueDisplay(queueViewModel) {
            console.log('Updating queue display with data:', queueViewModel);
            
            // Handle potential null or undefined response
            if (!queueViewModel) {
                console.error('Invalid queue data received');
                return;
            }
            
            queue = queueViewModel.queue || [];
            currentlyPlaying = queueViewModel.currentlyPlaying;
            
            // Update queue status indicators
            const totalSongs = queue.length;
            $('#totalSongs').text(totalSongs);
            
            const isPlaying = currentlyPlaying != null;
            $('#playingStatus').text(isPlaying ? 'Playing' : 'Not playing')
                .removeClass('bg-success bg-secondary')
                .addClass(isPlaying ? 'bg-success' : 'bg-secondary');

            // Update now playing section
            updateNowPlaying(currentlyPlaying);

            // Update queue list
            const songQueue = $('#songQueue');
            songQueue.empty();
            if (!queue.length) {
                songQueue.html('<p class="text-muted text-center p-3">The queue is empty.</p>');
                return;
            }

            queue.forEach((song, idx) => {
                // Highlight currently playing song in the queue if it exists there
                const isCurrentlyPlaying = currentlyPlaying && song.youtubeVideoId === currentlyPlaying.youtubeVideoId;
                const itemClass = isCurrentlyPlaying ? 'list-group-item active' : 'list-group-item';
                
                const item = `<div class="${itemClass}">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <div class="d-flex align-items-center mb-1">
                                <span class="badge ${isCurrentlyPlaying ? 'bg-light text-dark' : 'bg-secondary'} me-2">${idx+1}</span>
                                <h6 class="mb-0">${song.title}</h6>
                                ${isCurrentlyPlaying ? '<span class="ms-2 badge bg-warning">Now Playing</span>' : ''}
                            </div>
                            <small class="${isCurrentlyPlaying ? 'text-light' : 'text-muted'}">
                                <i class="bi bi-person"></i> ${song.requesterName} ${song.note ? '- ' + song.note : ''}
                            </small>
                        </div>
                        <button class="btn btn-sm ${isCurrentlyPlaying ? 'btn-outline-light' : 'btn-outline-danger'} ms-2" 
                                onclick="removeSong('${song.youtubeVideoId}')"
                                ${isCurrentlyPlaying ? 'disabled' : ''}>
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>`;
                songQueue.append(item);
            });
            
            console.log('Queue display updated successfully');
        }

        function updateNowPlaying(song) {
            console.log('Updating now playing with song:', song);
            const nowPlayingDiv = $('#nowPlaying');
            
            if (!song) {
                nowPlayingDiv.html('<p class="text-muted">No song is currently playing</p>');
                return;
            }
            
            // Calculate progress if available
            let progressHtml = '';
            if (song.startedAt && song.duration) {
                const startTime = new Date(song.startedAt);
                const totalSeconds = song.duration.totalSeconds || Math.floor(song.duration / 1000);
                const elapsedSeconds = Math.floor((new Date() - startTime) / 1000);
                const progress = Math.min(100, Math.floor((elapsedSeconds / totalSeconds) * 100));
                
                progressHtml = `
                    <div class="progress mb-2" style="height: 5px;">
                        <div class="progress-bar bg-success" role="progressbar" style="width: ${progress}%" 
                             aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <p class="small text-muted mb-2">
                        ${formatTime(elapsedSeconds)} / ${formatTime(totalSeconds)}
                    </p>`;
            }
            
            nowPlayingDiv.html(`
                <h5 class="mb-1">${song.title}</h5>
                ${progressHtml}
                <p class="mb-0 text-muted">
                    <i class="bi bi-person-fill"></i> Requested by: ${song.requesterName}
                    ${song.note ? '<br><i class="bi bi-chat-text"></i> Note: ' + song.note : ''}
                </p>
            `);
        }
        
        // Helper function to format time in MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function searchSongs() {
            const query = $('#searchQuery').val().trim();
            if (!query) return;

            $('#searchButton').prop('disabled', true).html('<span class="spinner-border spinner-border-sm"></span> Searching...');
            $.post('/Song/Search', { query })
                .done(resp => resp.success === false ? alert(resp.message || 'Error') : displaySearchResults(resp.results))
                .fail(() => alert('Error searching songs'))
                .always(() => $('#searchButton').prop('disabled', false).html('<i class="bi bi-search"></i> Search'));
        }

        function displaySearchResults(results) {
            const container = $('#searchResults');
            container.empty();
            if (!results.length) return container.html('<p class="text-center text-muted">No results found.</p>');

            results.forEach(result => {
                const card = `<div class="col-md-6 mb-3">
                    <div class="card h-100 shadow-sm">
                        <img src="${result.thumbnailUrl}" class="card-img-top" style="height:120px;object-fit:cover">
                        <div class="card-body p-2">
                            <h6 class="card-title text-truncate" title="${result.title}">${result.title}</h6>
                            <p class="card-text small text-muted">${result.channelTitle} - ${result.durationDisplay}</p>
                            <button class="btn btn-sm btn-primary w-100" onclick="requestSong('${result.videoId}', \`${result.title.replace(/`/g,'\\`')}\`)">
                                <i class="bi bi-plus-circle"></i> Add to Queue
                            </button>
                        </div>
                    </div>
                </div>`;
                container.append(card);
            });
        }

        function requestSong(videoId, title) {
            $('#requestModalVideoId').val(videoId);
            $('#requestModalTitle').val(title);
            $('#requestModalSongTitle').text(title);
            $('#requesterName').val('');
            $('#requesterNote').val('');
            $('#requesterNameError').hide();
            $('#requestModal').modal('show');
        }

        function confirmRequest() {
            const videoId = $('#requestModalVideoId').val();
            const title = $('#requestModalTitle').val();
            const requesterName = $('#requesterName').val().trim();
            const note = $('#requesterNote').val().trim();

            if (!requesterName) return $('#requesterNameError').show();
            $('#requesterNameError').hide();
            $('#requestModal').modal('hide');

            $.post('/Song/RequestSong', { videoId, title, requesterName, note })
                .done(() => { showToast(`"${title}" added to queue!`, 'success'); $('#searchResults').empty(); $('#searchQuery').val(''); loadQueueStatus(); })
                .fail(() => showToast('Error adding song', 'danger'));
        }

        function removeSong(videoId) {
            if (!confirm('Remove this song from queue?')) return;
            $.post('/Song/RemoveSong', { videoId })
                .done(() => { showToast('Song removed from queue','info'); loadQueueStatus(); })
                .fail(() => showToast('Error removing song','danger'));
        }

        function clearQueue() {
            if (!confirm('Clear entire queue?')) return;
            $.post('/Song/ClearQueue')
                .done(() => { showToast('Queue cleared','info'); loadQueueStatus(); })
                .fail(() => showToast('Error clearing queue','danger'));
        }

        function loadQueueStatus() {
            console.log('Loading queue status...');
            $.get('/Song/GetQueueStatus')
                .done(response => {
                    console.log('Queue status loaded successfully:', response);
                    updateQueueDisplay(response);
                })
                .fail(error => {
                    console.error('Error loading queue status:', error);
                    showToast('Failed to load queue status. Please try again.', 'danger');
                });
        }

        function showToast(message, type='success') {
            const toastHtml = `<div class="toast align-items-center text-white bg-${type} border-0" role="alert" style="position:fixed;top:20px;right:20px;z-index:9999;">
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>`;
            $('body').append(toastHtml);
            const toastEl = $('.toast').last()[0];
            const toast = new bootstrap.Toast(toastEl, { delay: 3000 });
            toast.show();
            setTimeout(() => $(toastEl).remove(), 4000);
        }
    </script>
}
